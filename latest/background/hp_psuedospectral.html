<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>hp-psuedospectral method · NLOptControl.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NLOptControl.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/BrysonDenham/main.html">Bryson Denham</a></li><li><a class="toctext" href="../tutorials/Brachistochrone/main.html">Brachistochrone</a></li><li><a class="toctext" href="../tutorials/HyperSensitive/main.html">HyperSensitive</a></li><li><a class="toctext" href="../tutorials/MoonLander/main.html">Moon Lander</a></li><li><a class="toctext" href="../tutorials/KinematicBicycle/main.html">Kinematic Bicycle Model</a></li></ul></li><li><span class="toctext">Background Information</span><ul><li><a class="toctext" href="lagrange_poly.html">Lagrange Interpolating Polynomials</a></li><li><a class="toctext" href="ocp.html">Optimal Control Problem Definition</a></li><li><a class="toctext" href="time_marching.html">Time Marching Methods</a></li><li><a class="toctext" href="pseudospectral_methods.html">Pseudospectral Methods</a></li><li class="current"><a class="toctext" href="hp_psuedospectral.html">hp-psuedospectral method</a><ul class="internal"><li><a class="toctext" href="#Single-Phase-Optimal-Control-1">Single Phase Optimal Control</a></li><li><a class="toctext" href="#Change-of-Interval-1">Change of Interval</a></li><li><a class="toctext" href="#Divide-The-Interval-\\tau-\\in-[-1,1]-1">Divide The Interval <span>$\tau \in [-1,+1]$</span></a></li><li><a class="toctext" href="#Rewrite-the-Optimal-Control-Problem-using-the-Mesh-1">Rewrite the Optimal Control Problem using the Mesh</a></li><li><a class="toctext" href="#Optimal-Control-Problem-Approximation-1">Optimal Control Problem Approximation</a></li></ul></li></ul></li><li><span class="toctext">Exported Functions</span><ul><li><a class="toctext" href="../functions/NLOptControl.html">NLOptControl.jl</a></li><li><a class="toctext" href="../functions/VehicleModels.html">VehicleModels.jl</a></li><li><a class="toctext" href="../functions/PrettyPlots.html">PrettyPlots.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Background Information</li><li><a href="hp_psuedospectral.html">hp-psuedospectral method</a></li></ul><a class="edit-page" href="https://github.com/JuliaMPC/MPCDocs.jl/tree/469df3f63021df362e803ae7beee183c57d3b468/docs/src/background/hp_psuedospectral.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>hp-psuedospectral method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="hp-psuedospectral-method-1" href="#hp-psuedospectral-method-1">hp-psuedospectral method</a></h1><p>To solve the integral constraints within the optimal control problem we employs the hp-pseudospectral method. The hp-psuedospectral method is an form of Gaussian Quadrature, which uses multi-interval collocation points.</p><h2><a class="nav-anchor" id="Single-Phase-Optimal-Control-1" href="#Single-Phase-Optimal-Control-1">Single Phase Optimal Control</a></h2><p>Find:</p><blockquote><ul><li><p>The state: <span>$\mathbf{x}(t)$</span></p></li><li><p>The control: <span>$\mathbf{u}(t)$</span></p></li><li><p>The integrals: <span>$\mathbf{q}$</span></p></li><li><p>The initial time: <span>$t_0$</span></p></li><li><p>The final time: <span>$t_f$</span></p></li></ul></blockquote><p>To Minimize: :   <span>$J = \Phi(\mathbf{x}(t_0),\mathbf{x}(t_f),\mathbf{q},t_0,t_f)$</span></p><p>That Satisfy the Following Constraints:</p><blockquote><ul><li><p>Dynamic Constraints:</p></li></ul><blockquote><div>\[\frac{\mathrm{d}\mathbf{x}}{\mathrm{d}t} = \mathbf{\psi}(\mathbf{x}(t),\mathbf{u}(t),t)\]</div></blockquote><ul><li><p>Inequality Path Constraints:</p></li></ul><div>\[\mathbf{c}_{min} &lt;= \mathbf{c}(\mathbf{x}(t),\mathbf{u}(t),t) &lt;= \mathbf{c}_{max}\]</div><ul><li><p>Integral Constraints:</p></li></ul><div>\[q_i = \int_{t_0}^{t_f} \Upsilon_i(\mathbf{x}(t),\mathbf{u}(t),t)\, \mathrm{d}t,\;\;(i=1,....,n_q)\]</div><ul><li><p>Event Constraints:</p></li></ul><div>\[\mathbf{b}_{min} &lt;= \mathbf{b}(\mathbf{x}(t_0),\mathbf{x}(t_f),t_f,\mathbf{q}) &lt;= \mathbf{b}_{max}\]</div></blockquote><h2><a class="nav-anchor" id="Change-of-Interval-1" href="#Change-of-Interval-1">Change of Interval</a></h2><p>To can change the limits of the integration (in order to apply Quadrature), we introduce <span>$\tau \in [-1,+1]$</span> as a new independent variable and perform a change of variable for <span>$t$</span> in terms of <span>$\tau$</span>, by defining:</p><blockquote><div>\[t = \frac{t_f - t_0}{2}\tau + \frac{t_f + t_0}{2}\]</div></blockquote><p>The optimal control problem defined above (TODO: figure out equation references), is now redefined in terms of <span>$\tau$</span> as:</p><p>Find:</p><blockquote><ul><li><p>The state: <span>$\mathbf{x}(\tau)$</span></p></li><li><p>The control: <span>$\mathbf{u}(\tau)$</span></p></li><li><p>The integrals: <span>$\mathbf{q}$</span></p></li><li><p>The initial time: <span>$t_0$</span></p></li><li><p>The final time: <span>$t_f$</span></p></li></ul></blockquote><p>To Minimize: :   <span>$J = \Phi(\mathbf{x}(-1),\mathbf{x}(+1),\mathbf{q},t_0,t_f)$</span></p><p>That Satisfy the Following Constraints:</p><blockquote><ul><li><p>Dynamic Constraints:</p></li></ul><blockquote><div>\[\frac{\mathrm{d}\mathbf{x}}{\mathrm{d}\tau} = \frac{t_f-t_0}{2} \mathbf{\psi}(\mathbf{x}(\tau),\mathbf{u}(\tau),\tau,t_0,t_f)\]</div></blockquote><ul><li><p>Inequality Path Constraints:</p></li></ul><div>\[\mathbf{c}_{min} &lt;= \mathbf{c}(\mathbf{x}(\tau),\mathbf{u}(\tau),\tau,t_0,t_f) &lt;= \mathbf{c}_{max}\]</div><ul><li><p>Integral Constraints:</p></li></ul><div>\[q_i = \frac{t_f-t_0}{2} \int_{-1}^{+1} \Upsilon_i(\mathbf{x}(\tau),\mathbf{u}(\tau),\tau,t_0,t_f)\, \mathrm{d}\tau,\;\;(i=1,....,n_q)\]</div><ul><li><p>Event Constraints:</p></li></ul><div>\[\mathbf{b}_{min} &lt;= \mathbf{b}(\mathbf{x}(-1),\mathbf{x}(+1),t_f,\mathbf{q}) &lt;= \mathbf{b}_{max}\]</div></blockquote><h2><a class="nav-anchor" id="Divide-The-Interval-\\tau-\\in-[-1,1]-1" href="#Divide-The-Interval-\\tau-\\in-[-1,1]-1">Divide The Interval <span>$\tau \in [-1,+1]$</span></a></h2><p>The interval <span>$\tau \in [-1,+1]$</span> is now divided into a mesh of K mesh intervals as: :   <span>$[T_{k-1},T_k], k = 1,...,T_K$</span></p><p>with <span>$(T_0,...,T_K)$</span> being the mesh points; which satisfy: :   <span>$-1 = T_0 &lt; T_1 &lt; T_2 &lt; T_3 &lt; ........... &lt; T_{K-1} &lt; T_K = T_f = +1$</span></p><h2><a class="nav-anchor" id="Rewrite-the-Optimal-Control-Problem-using-the-Mesh-1" href="#Rewrite-the-Optimal-Control-Problem-using-the-Mesh-1">Rewrite the Optimal Control Problem using the Mesh</a></h2><p>Find:</p><blockquote><ul><li><p>The state : <span>$\mathbf{x}^{(k)}(\tau)$</span> <strong>in mesh interval k</strong></p></li><li><p>The control: <span>$\mathbf{u}^{(k)}(\tau)$</span> <strong>in mesh interval k</strong></p></li><li><p>The integrals: <span>$\mathbf{q}$</span></p></li><li><p>The initial time: <span>$t_0$</span></p></li><li><p>The final time: <span>$t_f$</span></p></li></ul></blockquote><p>To Minimize: :   <span>$J = \Phi(\mathbf{x}^{(1)}(-1),\mathbf{x}^{(K)}(+1),\mathbf{q},t_0,t_f)$</span></p><p>That Satisfy the Following Constraints:</p><ul><li><p>Dynamic Constraints:</p></li></ul><blockquote><div>\[\frac{\mathrm{d}\mathbf{x}^{(k)}(\tau^{(k)})}{\mathrm{d}\tau^{(k)}} = \frac{t_f-t_0}{2} \mathbf{\psi}(\mathbf{x}^{(k)}(\tau^{(k)}),\mathbf{u}^{(k)}(\tau^{(k)}),\tau^{(k)},t_0,t_f),\;\;(k=1,...,K)\]</div></blockquote><ul><li><p>Inequality Path Constraints:</p></li></ul><div>\[\mathbf{c}_{min} &lt;= \mathbf{c}(\mathbf{x}^{(k)}(\tau^{(k)}),\mathbf{u}^{(k)}(\tau^{(k)}),\tau^{(k)},t_0,t_f) &lt;= \mathbf{c}_{max},\;\;(k=1,...,K)\]</div><ul><li><p>Integral Constraints:</p></li></ul><div>\[q_i = \frac{t_f-t_0}{2} \displaystyle\sum_{k=1}^{K} \int_{T_{k-1}}^{T_k} \Upsilon_i(\mathbf{x}^{(k)}(\tau^{(k)}),\mathbf{u}^{(k)}(\tau^{(k)}),\tau,t_0,t_f)\, \mathrm{d}\tau,\;\;(i=1,....,n_q, k=1,...,K)\]</div><ul><li><p>Event Constraints:</p></li></ul><div>\[\mathbf{b}_{min} &lt;= \mathbf{b}(\mathbf{x}^{(1)}(-1),\mathbf{x}^{(K)}(+1),t_f,\mathbf{q}) &lt;= \mathbf{b}_{max}\]</div><ul><li><p>State Continuity</p><blockquote><ul><li><p>Also, we must <strong>now</strong> constrain the state to be continuous at   each interior mesh point <span>$(T_1,...T_{k-1})$</span> by enforcing:</p><p><span>$\mathbf{y}^{k}(T_k) = \mathbf{y}^{k+1}(T_k)$</span></p></li></ul></blockquote></li></ul><h2><a class="nav-anchor" id="Optimal-Control-Problem-Approximation-1" href="#Optimal-Control-Problem-Approximation-1">Optimal Control Problem Approximation</a></h2><p>The optimal control problem will now be approximated using the Radau Collocation Method as which follows the description provided by b-garg2011advances. In collocation methods, the state and control are discretized at particular points within the selected time interval. Once this is done the problem can be transcribed into a nonlinear programming problem (NLP) and solved using standard solvers for these types of problems, such as IPOPT or KNITRO.</p><p>For each mesh interval <span>$k\in[1,..,K]$</span>: :   <span>$:nowrap:$$$$\begin{eqnarray}      \mathbf{x}^{(k)}(\tau)&amp;\approx\mathbf{X}^{(k)}(\tau)=\displaystyle\sum_{j=1}^{N_k+1}\mathbf{X}_j^{(k)}\frac{\mathrm{d}\mathcal{L}_j^{k}(\tau)}{\mathrm{d}\tau}\\
      where,\;\;&amp;\\
     \mathcal{L}_j^{k}(\tau)&amp;=\prod_{\substack{l=1 \\ l\neq j}}^{N_k+1}\frac{\tau-\tau_l^{(k)}}{\tau_j^{(k)}-\tau_l^{(k)}}\\
           and,\;\;&amp;\\
           &amp;D_{ki}=\dot{\mathcal{L}}_i(\tau_k)=\frac{\mathrm{d}\mathcal{L}_j^{k}(\tau)}{\mathrm{d}\tau}         \end{eqnarray}$</span></p><p>also, :   -   <span>$\mathcal{L}_j^{(k)}(\tau),\;\;(j=1,...,N_k+1)$</span> is a basis of         Lagrange polynomials     -   <span>$(\tau_1^{k},.....,\tau_{N_k}^{(k)})$</span> are the         Legendre-Gauss-Radau collocation points in mesh interval k</p><pre><code class="language-none">    &gt; -   defined on the subinterval $\tau^{(k)}\in[T_{k-1},T_k]$
    &gt; -   $\tau_{N_k+1}^{(k)}=T_k$ is a noncollocated point</code></pre><p>A basic description of Lagrange Polynomials is presented in lagrange_poly</p><p>The <span>$\mathbf{D}$</span> matrix: :   -   Has a size <span>$= [N_c]\times[N_c+1]$</span>         :   -   with <span>$(1&lt;=k&lt;=N_c), (1&lt;=i&lt;=N_c+1)$</span>             -   this non-square shape because the state approximation uses the <span>$N_c+1$</span> points:                 :   <span>$(\tau_1,...\tau_{N_c+1})$</span></p><pre><code class="language-none">        -   but collocation is only done at the $N_c$ LGR points:
            :   $(\tau_1,...\tau_{N_c})$</code></pre><p>If we define the state matrix as:</p><div>\[:nowrap:$$$$\begin{equation}
  \mathbf{X}^{LGR}= \left [
  \begin{aligned}
    &amp;\mathbf{X}_1\\
    &amp;.\\
            &amp;.\\
            &amp;.\\
    &amp;\mathbf{X}_{N_c+1}
  \end{aligned} ] \right.
\end{equation}\]</div><p>The dynamics are collocated at the <span>$N_c$</span> LGR points using:</p><blockquote><div>\[\mathbf{D}_k\mathbf{X}^{LGR} = \frac{(t_f-t_0)}{2}\mathbf{f}(\mathbf{X}_k,\mathbf{U}_k,\tau,t_0,t_f)\;\;for\;\;k = {1,...,Nc}\]</div><p>with, :   -   <span>$\mathbf{D}_k$</span> being the <span>$k^{th}$</span> row of the <span>$\mathbf{D}$</span>         matrix.</p></blockquote><p><strong>References</strong></p><footer><hr/><a class="previous" href="pseudospectral_methods.html"><span class="direction">Previous</span><span class="title">Pseudospectral Methods</span></a><a class="next" href="../functions/NLOptControl.html"><span class="direction">Next</span><span class="title">NLOptControl.jl</span></a></footer></article></body></html>
