<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · NLOptControl.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NLOptControl.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../Brachistochrone/main.html">Quick Example 1: Brachistochrone</a></li><li class="current"><a class="toctext" href="main.html">-</a><ul class="internal"><li><a class="toctext" href="#Quick-Example-2:-Moon-Lander-1">Quick Example 2: Moon Lander</a></li><li><a class="toctext" href="#Solution:-1">Solution:</a></li><li><a class="toctext" href="#Packages-that-will-be-used-1">Packages that will be used</a></li><li><a class="toctext" href="#Define-the-Problem:-1">Define the Problem:</a></li><li><a class="toctext" href="#State-and-Control-Names-1">State and Control Names</a></li><li><a class="toctext" href="#Differential-Equations-1">Differential Equations</a></li><li><a class="toctext" href="#Configure-the-Problem:-1">Configure the Problem:</a></li><li><a class="toctext" href="#Integral-Terms-in-the-Cost-Function-1">Integral Terms in the Cost Function</a></li><li><a class="toctext" href="#Optimize-1">Optimize</a></li><li><a class="toctext" href="#Post-Process-1">Post Process</a></li><li><a class="toctext" href="#Other-Dynamic-Constraint-Methods-1">Other Dynamic Constraint Methods</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#Tolerances-1">Tolerances</a></li></ul></li><li><a class="toctext" href="../BrysonDenham/main.html">Bryson Denham</a></li><li><a class="toctext" href="../Beam/main.html">Beam Problem</a></li><li><a class="toctext" href="../HyperSensitive/main.html">HyperSensitive</a></li><li><a class="toctext" href="../RobotArm/main.html">RobotArm</a></li><li><a class="toctext" href="../Rocket/main.html">Rocket</a></li><li><a class="toctext" href="../KinematicBicycle/main.html">Kinematic Bicycle Model</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="main.html">-</a></li></ul><a class="edit-page" href="https://github.com/JuliaMPC/MPCDocs.jl/tree/5d63b1b5f9ab83b616b091bdab6c7e44488224e7/docs/src/tutorials/MoonLander/main.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>-</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Quick-Example-2:-Moon-Lander-1" href="#Quick-Example-2:-Moon-Lander-1">Quick Example 2: Moon Lander</a></h2><h3><a class="nav-anchor" id="Given:-1" href="#Given:-1">Given:</a></h3><h4><a class="nav-anchor" id="A-space-ship-landing-on-the-moon-1" href="#A-space-ship-landing-on-the-moon-1">A space-ship landing on the moon</a></h4><h4><a class="nav-anchor" id="Dynamic-Constraints-1" href="#Dynamic-Constraints-1">Dynamic Constraints</a></h4><div>\[\dot{x}_1(t)=x_2(t)\]</div><div>\[\dot{x}_2(t)=u(t)-g\]</div><h4><a class="nav-anchor" id="Boundary-Conditions-1" href="#Boundary-Conditions-1">Boundary Conditions</a></h4><div>\[{x}_1(0)=10 \qquad {x}_1(t_f)=0\]</div><div>\[{x}_2(0)=-2\qquad {x}_2(t_f)=0\]</div><h4><a class="nav-anchor" id="Control-Limits-1" href="#Control-Limits-1">Control Limits</a></h4><div>\[{u}_{1_{min}}=0 $$
$${u}_{1_{max}}=3 $$

### Find:
#### The track that minimizes time
$$J=\int_{0}^{tf} u(t) dt\]</div><h2><a class="nav-anchor" id="Solution:-1" href="#Solution:-1">Solution:</a></h2><p>In this problem, we put the bounds directly into <code>define()</code>. Also, now we have constant limits on the control variables and those can be added as shown below This problem can be found <a href="http://www.gpops2.com/Examples/MoonLander.html">here</a>.</p><h2><a class="nav-anchor" id="Packages-that-will-be-used-1" href="#Packages-that-will-be-used-1">Packages that will be used</a></h2><div><pre><code class="language-julia">using NLOptControl</code></pre></div><h2><a class="nav-anchor" id="Define-the-Problem:-1" href="#Define-the-Problem:-1">Define the Problem:</a></h2><p>In this problem, we put the bounds directly into <code>define()</code>. Also, now we have constant limits on the control variables and those can be added as shown below</p><pre><code class="language-">n=define(numStates=2,numControls=1,X0=[10.,-2],XF=[0.,0.],CL=[0.],CU=[3.]);
nothing # hide</code></pre><h2><a class="nav-anchor" id="State-and-Control-Names-1" href="#State-and-Control-Names-1">State and Control Names</a></h2><p>The state and control variables are by default, <span>$:x1,:x2,..$</span> and <span>$:u1,:u2,..$</span>, but they can be changed with the following commands:</p><pre><code class="language-">states!(n,[:h,:v];descriptions=[&quot;h(t)&quot;,&quot;v(t)&quot;]);
controls!(n,[:T];descriptions=[&quot;T(t)&quot;]);</code></pre><p>Next, now that the problem is configured, all of the state and control variables are stored in JuMP Arrays, <code>n.r.x[:,:]</code> and <code>n.r.u[:,:]</code>, respectively. For instance;</p><pre><code class="language-">typeof(n.r.x)</code></pre><h2><a class="nav-anchor" id="Differential-Equations-1" href="#Differential-Equations-1">Differential Equations</a></h2><pre><code class="language-">dx=[:(v[j]),:(T[j]-1.625)]
dynamics!(n,dx)
nothing # hide</code></pre><h2><a class="nav-anchor" id="Configure-the-Problem:-1" href="#Configure-the-Problem:-1">Configure the Problem:</a></h2><pre><code class="language-">configure!(n;(:finalTimeDV=&gt;true));
nothing # hide</code></pre><h2><a class="nav-anchor" id="Integral-Terms-in-the-Cost-Function-1" href="#Integral-Terms-in-the-Cost-Function-1">Integral Terms in the Cost Function</a></h2><p><code>integrate!()</code> is used to make terms that can be added to the cost function that need to be integrated. When calling this function an expression must be passed:</p><p>In this example the first control variable <code>T</code>needs to be integrated, it must be passed in an expression <code>:()</code> with the index <code>[j]</code>. To do this, <code>integrate!()</code> can be used as:</p><pre><code class="language-">obj=integrate!(n,:(T[j]));
# Now this term can be added as the objective function and the problem can be solved
@NLobjective(n.mdl, Min, obj);
nothing # hide</code></pre><h2><a class="nav-anchor" id="Optimize-1" href="#Optimize-1">Optimize</a></h2><pre><code class="language-">optimize!(n);
nothing # hide</code></pre><h2><a class="nav-anchor" id="Post-Process-1" href="#Post-Process-1">Post Process</a></h2><pre><code class="language-">using PrettyPlots
allPlots(n)</code></pre><h2><a class="nav-anchor" id="Other-Dynamic-Constraint-Methods-1" href="#Other-Dynamic-Constraint-Methods-1">Other Dynamic Constraint Methods</a></h2><p>Currently there are three different methods to ensure that the dyanamic constraints are satisfied and they are set when <code>configure!()</code> is called using the <code>:integrationScheme</code> key. They are listed below:</p><table><tr><th><code>:integrateScheme</code></th><th>Description</th></tr><tr><td><code>:lgrExplicit</code></td><td>default scheme; implementation derivative constraints in hp-pseudospecral method</td></tr><tr><td><code>:lgrImplicit</code></td><td>implementation of integral constraints in hp-pseudospecral method</td></tr><tr><td><code>:bkwEuler</code></td><td>approximate using backward euler method</td></tr><tr><td><code>:trapezoidal</code></td><td>approximate using trapezoidal method</td></tr></table><p>The later two are time-marching methods and default number of points is <code>100</code>, but that can be changed by setting <code>N</code>. So, the above problem can be solved using one of the time-marching schemes as:</p><pre><code class="language-">n=define(numStates=2,numControls=1,X0=[10.,-2],XF=[0.,0.],CL=[0.],CU=[3.]);
states!(n,[:h,:v];descriptions=[&quot;h(t)&quot;,&quot;v(t)&quot;]);
controls!(n,[:T];descriptions=[&quot;T(t)&quot;]);
dx=[:(v[j]),:(T[j]-1.625)]
dynamics!(n,dx)
configure!(n,N=200;(:integrationScheme=&gt;:trapezoidal),(:finalTimeDV=&gt;true));
obj=integrate!(n,:(T[j]));
@NLobjective(n.mdl, Min, obj);
optimize!(n);
allPlots(n)</code></pre><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><p>Often when building a model and using it to solve an optimal control problem, their are issues associated with infeasibility. <code>NLOptControl</code> has functionality to help deal with these issues. For instance, the dual infeasibility values can stored and quickly viewed. They are stored in an array of DataFrames which can be referenced with <code>n.r.dfs_con</code> as:</p><pre><code class="language-">n.r.dfs_con</code></pre><p>It is empty, because by default this data is not calculated and stored. This option can be turned on by modifying the settings for the problem:</p><pre><code class="language-">n.s.evalConstraints</code></pre><pre><code class="language-">n.s.evalConstraints=true;
optimize!(n);
n.r.dfs_con</code></pre><pre><code class="language-">evalMaxDualInf(n)</code></pre><p>The last function called, searches through all of the <code>dual infeasibilities</code> to find the largest value. As, this problem is, it is feasible and optimal. But if there was an issue, often looking for high values in these DataFrame structures is the quickest way to figure out the constraints that are giving the solver trouble.</p><h2><a class="nav-anchor" id="Tolerances-1" href="#Tolerances-1">Tolerances</a></h2><p>If there was an example where the <code>dual infeasibility</code> value for one or more of the variables was very high, but the actual constraint is only being violated slightly (by some reasonable amount) then the tolerances on the initial and terminal states can be adjusted. This will also improve the solve time, so it is good practice to set these to reasonable values. For instance, in the <code>Moon Lander</code> example, we can set them as:</p><pre><code class="language-">n=define(numStates=2,numControls=1,X0=[10.,-2],XF=[0.,0.],CL=[0.],CU=[3.]);
states!(n,[:h,:v];descriptions=[&quot;h(t)&quot;,&quot;v(t)&quot;]);
controls!(n,[:T];descriptions=[&quot;T(t)&quot;]);
dx=[:(v[j]),:(T[j]-1.625)]
dynamics!(n,dx)
XF_tol=[2.0,0.5];
X0_tol=[0.05,0.05];
defineTolerances!(n;X0_tol=X0_tol,XF_tol=XF_tol);
configure!(n,N=50;(:integrationScheme=&gt;:bkwEuler),(:finalTimeDV=&gt;true));
obj=integrate!(n,:(T[j]));
@NLobjective(n.mdl, Min, obj);
optimize!(n);
allPlots(n)</code></pre><footer><hr/><a class="previous" href="../Brachistochrone/main.html"><span class="direction">Previous</span><span class="title">Quick Example 1: Brachistochrone</span></a><a class="next" href="../BrysonDenham/main.html"><span class="direction">Next</span><span class="title">Bryson Denham</span></a></footer></article></body></html>
